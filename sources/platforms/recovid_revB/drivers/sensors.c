#include "recovid_revB.h"
#include "platform.h"
#include "bmp280.h"
#include <string.h>
#include <float.h>
#include <math.h>

/*
 * Notes concernant l'utilisation du bmp280.
 *
 * - La fonction d'initialisation utilise directement la lib Bosch de façon synchrone.
 *
 * - Cette lib  n'est pas adaptée pour une utilisation asynchrone avec usage d'interruptions,
 * la partie lecture dans la boucle principale, interroge directement le capteur sans passer par
 * la lib pour récupérer les valeurs brutes. La compensation des valeurs est effectuée par un appel à une
 * fonction de la lib Bosch.
 *
 */
/*
 * The sequence of reading is now REQ_SDP_MEASUREMENT->READ_SDP_MEASUREMENT-> READ_BMP280_STAGE_1 -> READ_BMP280_STAGE_2 -> READ_NPA_MEASUREMENT
                                      |________________________________________<__________________________________________________|

 */
typedef enum {
	STOPPED,
	STOPPING,
	REQ_SDP_MEASUREMENT,
	READ_SDP_MEASUREMENT,
	READ_NPA_MEASUREMENT,
    READ_BMP280_STAGE_1,
    READ_BMP280_STAGE_2,
} sensors_state_t;


const float				TAB_sqrtf[ 1200 ] = { 0, 
0.316227766016838, 
0.447213595499958, 
0.547722557505166, 
0.632455532033676, 
0.707106781186548, 
0.774596669241483, 
0.836660026534076, 
0.894427190999916, 
0.948683298050514, 
1, 
1.04880884817015, 
1.09544511501033, 
1.14017542509914, 
1.18321595661992, 
1.22474487139159, 
1.26491106406735, 
1.30384048104053, 
1.34164078649987, 
1.37840487520902, 
1.4142135623731, 
1.44913767461894, 
1.48323969741913, 
1.51657508881031, 
1.54919333848297, 
1.58113883008419, 
1.61245154965971, 
1.6431676725155, 
1.67332005306815, 
1.70293863659264, 
1.73205080756888, 
1.7606816861659, 
1.78885438199983, 
1.8165902124585, 
1.84390889145858, 
1.87082869338697, 
1.89736659610103, 
1.92353840616713, 
1.94935886896179, 
1.97484176581315, 
2, 
2.02484567313166, 
2.04939015319192, 
2.07364413533277, 
2.0976176963403, 
2.12132034355964, 
2.14476105895272, 
2.16794833886788, 
2.19089023002066, 
2.21359436211787, 
2.23606797749979, 
2.25831795812724, 
2.28035085019828, 
2.30217288664427, 
2.32379000772445, 
2.34520787991171, 
2.36643191323985, 
2.38746727726266, 
2.40831891575846, 
2.42899156029822, 
2.44948974278318, 
2.46981780704569, 
2.48997991959775, 
2.50998007960223, 
2.5298221281347, 
2.54950975679639, 
2.56904651573303, 
2.58843582110896, 
2.60768096208106, 
2.62678510731274, 
2.64575131106459, 
2.66458251889485, 
2.68328157299975, 
2.70185121722126, 
2.72029410174709, 
2.73861278752583, 
2.75680975041804, 
2.77488738510232, 
2.79284800875379, 
2.81069386451104, 
2.82842712474619, 
2.84604989415154, 
2.86356421265527, 
2.88097205817759, 
2.89827534923789, 
2.91547594742265, 
2.93257565972304, 
2.94957624075053, 
2.96647939483827, 
2.98328677803526, 
3, 
3.01662062579967, 
3.03315017762062, 
3.04959013639538, 
3.06594194335118, 
3.08220700148449, 
3.09838667696593, 
3.11448230047949, 
3.13049516849971, 
3.14642654451045, 
3.16227766016838, 
3.17804971641414, 
3.19374388453426, 
3.20936130717624, 
3.22490309931942, 
3.24037034920393, 
3.25576411921994, 
3.27108544675923, 
3.286335345031, 
3.30151480384384, 
3.3166247903554, 
3.33166624979154, 
3.3466401061363, 
3.36154726279432, 
3.37638860322683, 
3.39116499156263, 
3.40587727318528, 
3.42052627529741, 
3.43511280746353, 
3.44963766213207, 
3.46410161513775, 
3.47850542618522, 
3.4928498393146, 
3.50713558335004, 
3.5213633723318, 
3.53553390593274, 
3.54964786985977, 
3.56370593624109, 
3.57770876399966, 
3.59165699921359, 
3.60555127546399, 
3.61939221417077, 
3.63318042491699, 
3.64691650576209, 
3.66060104354463, 
3.67423461417477, 
3.68781778291715, 
3.70135110466435, 
3.71483512420134, 
3.72827037646145, 
3.74165738677394, 
3.75499667110372, 
3.76828873628335, 
3.78153408023781, 
3.79473319220205, 
3.80788655293195, 
3.82099463490856, 
3.83405790253616, 
3.84707681233427, 
3.86005181312376, 
3.87298334620742, 
3.88587184554509, 
3.89871773792359, 
3.91152144312159, 
3.92428337406972, 
3.93700393700591, 
3.9496835316263, 
3.96232255123179, 
3.97492138287036, 
3.98748040747538, 
4, 
4.01248052954778, 
4.02492235949962, 
4.03732584763727, 
4.04969134626332, 
4.06201920231798, 
4.07430975749267, 
4.08656334834051, 
4.09878030638384, 
4.11096095821889, 
4.12310562561766, 
4.13521462562707, 
4.14728827066554, 
4.15932686861708, 
4.17133072292284, 
4.18330013267038, 
4.19523539268061, 
4.20713679359253, 
4.2190046219458, 
4.23083916026124, 
4.24264068711929, 
4.25440947723653, 
4.26614580154031, 
4.27784992724149, 
4.28952211790544, 
4.30116263352131, 
4.31277173056957, 
4.32434966208793, 
4.33589667773576, 
4.34741302385683, 
4.35889894354067, 
4.37035467668243, 
4.38178046004133, 
4.39317652729776, 
4.40454310910905, 
4.41588043316392, 
4.42718872423573, 
4.43846820423443, 
4.4497190922574, 
4.46094160463909, 
4.47213595499958, 
4.48330235429198, 
4.49444101084885, 
4.50555213042752, 
4.51663591625449, 
4.52769256906871, 
4.53872228716409, 
4.54972526643093, 
4.56070170039655, 
4.57165178026498, 
4.58257569495584, 
4.59347363114234, 
4.60434577328854, 
4.61519230368573, 
4.62601340248815, 
4.63680924774785, 
4.6475800154489, 
4.65832587954085, 
4.6690470119715, 
4.67974358271904, 
4.69041575982343, 
4.70106370941726, 
4.7116875957559, 
4.72228758124704, 
4.73286382647969, 
4.74341649025257, 
4.75394572960189, 
4.76445169982864, 
4.77493455452533, 
4.78539444560216, 
4.79583152331272, 
4.80624593627917, 
4.81663783151692, 
4.82700735445887, 
4.83735464897913, 
4.84767985741633, 
4.85798312059645, 
4.86826457785524, 
4.87852436706019, 
4.88876262463213, 
4.89897948556636, 
4.90917508345343, 
4.91934955049954, 
4.9295030175465, 
4.93963561409139, 
4.94974746830583, 
4.9598387070549, 
4.96990945591567, 
4.97995983919549, 
4.98998997994986, 
5, 
5.00999001995014, 
5.01996015920445, 
5.02991053598372, 
5.03984126734166, 
5.04975246918104, 
5.05964425626941, 
5.06951674225463, 
5.07937003968012, 
5.08920425999979, 
5.09901951359278, 
5.10881590977792, 
5.11859355682789, 
5.12835256198323, 
5.13809303146605, 
5.1478150704935, 
5.15751878329105, 
5.16720427310553, 
5.17687164221791, 
5.18652099195598, 
5.19615242270663, 
5.20576603392815, 
5.21536192416212, 
5.22494019104525, 
5.23450093132096, 
5.24404424085076, 
5.25357021462548, 
5.26307894677631, 
5.27257053058563, 
5.2820450584977, 
5.29150262212918, 
5.30094331227943, 
5.3103672189407, 
5.31977443130815, 
5.32916503778969, 
5.33853912601566, 
5.34789678284838, 
5.35723809439155, 
5.3665631459995, 
5.37587202228625, 
5.3851648071345, 
5.39444158370447, 
5.40370243444252, 
5.41294744108974, 
5.42217668469038, 
5.43139024560011, 
5.44058820349418, 
5.44977063737549, 
5.45893762558247, 
5.46808924579693, 
5.47722557505166, 
5.48634668973808, 
5.49545266561363, 
5.50454357780915, 
5.51361950083609, 
5.52268050859363, 
5.53172667437573, 
5.54075807087803, 
5.54977477020464, 
5.55877684387492, 
5.56776436283002, 
5.57673739743948, 
5.58569601750758, 
5.59464029227975, 
5.60357029044876, 
5.61248608016091, 
5.62138772902208, 
5.6302753041037, 
5.63914887194867, 
5.64800849857718, 
5.65685424949238, 
5.66568618968612, 
5.67450438364444, 
5.68330889535313, 
5.69209978830308, 
5.70087712549569, 
5.70964096944808, 
5.71839138219832, 
5.72712842531054, 
5.73585215988, 
5.74456264653803, 
5.75325994545701, 
5.76194411635517, 
5.7706152185014, 
5.77927331071996, 
5.78791845139511, 
5.79655069847578, 
5.80517010948, 
5.81377674149945, 
5.82237065120385, 
5.8309518948453, 
5.83952052826257, 
5.84807660688538, 
5.85662018573853, 
5.86515131944607, 
5.87367006223537, 
5.8821764679411, 
5.89067059000926, 
5.89915248150105, 
5.90762219509677, 
5.91607978309962, 
5.92452529743945, 
5.93295878967653, 
5.94138031100518, 
5.94978991225741, 
5.95818764390649, 
5.96657355607052, 
5.97494769851586, 
5.98331012066064, 
5.9916608715781, 
6, 
6.00832755431992, 
6.01664358259653, 
6.02494813255683, 
6.03324125159934, 
6.04152298679729, 
6.04979338490167, 
6.05805249234438, 
6.06630035524124, 
6.07453701939498, 
6.08276253029822, 
6.09097693313642, 
6.09918027279076, 
6.10737259384099, 
6.11555394056826, 
6.12372435695795, 
6.13188388670236, 
6.1400325732035, 
6.14817045957576, 
6.15629758864855, 
6.16441400296898, 
6.17251974480439, 
6.18061485614498, 
6.18869937870632, 
6.19677335393187, 
6.20483682299543, 
6.21288982680363, 
6.22093240599832, 
6.22896460095898, 
6.23698645180507, 
6.2449979983984, 
6.25299928034539, 
6.26099033699941, 
6.26897120746299, 
6.27694193059009, 
6.28490254498827, 
6.29285308902091, 
6.30079360080935, 
6.308724118235, 
6.3166446789415, 
6.32455532033676, 
6.33245607959503, 
6.34034699365894, 
6.34822809924155, 
6.35609943282828, 
6.36396103067893, 
6.3718129288296, 
6.37965516309463, 
6.38748776906853, 
6.39531078212779, 
6.40312423743285, 
6.41092816992984, 
6.41872261435249, 
6.42650760522385, 
6.43428317685817, 
6.44204936336256, 
6.44980619863884, 
6.45755371638518, 
6.46529195009785, 
6.4730209330729, 
6.48074069840786, 
6.48845127900333, 
6.49615270756469, 
6.50384501660364, 
6.51152823843988, 
6.51920240520265, 
6.52686754883229, 
6.53452370108182, 
6.54217089351845, 
6.54980915752513, 
6.557438524302, 
6.56505902486794, 
6.57267069006199, 
6.58027355054484, 
6.58786763680024, 
6.59545297913646, 
6.60302960768767, 
6.61059755241536, 
6.61815684310972, 
6.62570750939098, 
6.6332495807108, 
6.6407830863536, 
6.64830805543787, 
6.65582451691749, 
6.66333249958307, 
6.67083203206317, 
6.6783231428256, 
6.68580586017871, 
6.6932802122726, 
6.70074622710038, 
6.70820393249937, 
6.71565335615233, 
6.72309452558864, 
6.73052746818554, 
6.73795221116921, 
6.74536878161602, 
6.75277720645365, 
6.76017751246223, 
6.76756972627545, 
6.77495387438173, 
6.78232998312527, 
6.78969807870718, 
6.79705818718657, 
6.8044103344816, 
6.81175454637056, 
6.81909084849293, 
6.82641926635041, 
6.83373982530796, 
6.84105255059483, 
6.84835746730557, 
6.85565460040104, 
6.8629439747094, 
6.87022561492707, 
6.87749954561976, 
6.8847657912234, 
6.89202437604511, 
6.89927532426414, 
6.9065186599328, 
6.91375440697744, 
6.92098258919931, 
6.92820323027551, 
6.93541635375988, 
6.94262198308391, 
6.94982014155762, 
6.95701085237044, 
6.96419413859206, 
6.97137002317335, 
6.97853852894716, 
6.98569967862919, 
6.99285349481884, 
7, 
7.00713921654194, 
7.01427116670007, 
7.02139587261678, 
7.02851335632223, 
7.03562363973514, 
7.0427267446636, 
7.04982269280583, 
7.05691150575094, 
7.06399320497975, 
7.07106781186548, 
7.07813534767456, 
7.08519583356734, 
7.09224929059886, 
7.09929573971954, 
7.10633520177595, 
7.1133676975115, 
7.12039324756716, 
7.12741187248218, 
7.13442359269479, 
7.14142842854285, 
7.14842640026461, 
7.15541752799933, 
7.16240183178799, 
7.16937933157397, 
7.17635004720366, 
7.18331399842719, 
7.19027120489902, 
7.19722168617863, 
7.20416546173115, 
7.21110255092798, 
7.21803297304744, 
7.22495674727538, 
7.23187389270582, 
7.23878442834154, 
7.24568837309472, 
7.2525857457875, 
7.25947656515262, 
7.26636084983398, 
7.27323861838727, 
7.28010988928052, 
7.28697468089467, 
7.29383301152419, 
7.30068489937759, 
7.30753036257805, 
7.3143694191639, 
7.32120208708925, 
7.3280283842245, 
7.3348483283569, 
7.34166193719106, 
7.34846922834953, 
7.35527021937332, 
7.36206492772238, 
7.36885337077622, 
7.37563556583431, 
7.3824115301167, 
7.38918128076447, 
7.39594483484024, 
7.4027022093287, 
7.40945342113708, 
7.41619848709566, 
7.42293742395825, 
7.42967024840268, 
7.43639697703128, 
7.44311762637136, 
7.44983221287567, 
7.4565407529229, 
7.46324326281812, 
7.46993975879324, 
7.4766302570075, 
7.48331477354788, 
7.4899933244296, 
7.49666592559653, 
7.50333259292163, 
7.50999334220744, 
7.51664818918645, 
7.52329714952161, 
7.52994023880668, 
7.53657747256671, 
7.54320886625844, 
7.54983443527075, 
7.55645419492503, 
7.56306816047562, 
7.56967634711023, 
7.57627876995033, 
7.58287544405155, 
7.58946638440411, 
7.59605160593318, 
7.60263112349929, 
7.60920495189872, 
7.61577310586391, 
7.6223356000638, 
7.62889244910426, 
7.63544366752843, 
7.64198926981712, 
7.64852927038918, 
7.65506368360186, 
7.66159252375118, 
7.66811580507233, 
7.67463354173996, 
7.68114574786861, 
7.68765243751303, 
7.69415362466854, 
7.70064932327138, 
7.70713954719908, 
7.71362431027076, 
7.72010362624751, 
7.72657750883274, 
7.73304597167248, 
7.73950902835574, 
7.74596669241483, 
7.75241897732572, 
7.75886589650833, 
7.76530746332687, 
7.77174369109018, 
7.77817459305202, 
7.78460018241143, 
7.79102047231298, 
7.79743547584717, 
7.80384520605067, 
7.81024967590665, 
7.81664889834512, 
7.82304288624318, 
7.82943165242535, 
7.83581520966389, 
7.84219357067906, 
7.84856674813943, 
7.85493475466219, 
7.86129760281342, 
7.86765530510838, 
7.87400787401181, 
7.88035532193822, 
7.88669766125214, 
7.89303490426845, 
7.8993670632526, 
7.90569415042095, 
7.91201617794099, 
7.91833315793166, 
7.92464510246358, 
7.93095202355934, 
7.93725393319377, 
7.9435508432942, 
7.94984276574072, 
7.95612971236644, 
7.96241169495775, 
7.96868872525461, 
7.97496081495075, 
7.98122797569397, 
7.98749021908634, 
7.99374755668454, 
8, 
8.00624756049924, 
8.01249024960405, 
8.01872807869178, 
8.02496105909555, 
8.03118920210451, 
8.03741251896405, 
8.04363102087608, 
8.04984471899924, 
8.05605362444913, 
8.06225774829855, 
8.06845710157772, 
8.07465169527454, 
8.08084154033477, 
8.08702664766229, 
8.09320702811932, 
8.09938269252664, 
8.10555365166378, 
8.1117199162693, 
8.11788149704096, 
8.12403840463596, 
8.13019064967114, 
8.1363382427232, 
8.14248119432891, 
8.14861951498535, 
8.15475321515005, 
8.16088230524127, 
8.16700679563817, 
8.17312669668102, 
8.17924201867141, 
8.18535277187245, 
8.19145896650896, 
8.19756061276768, 
8.20365772079747, 
8.20975030070952, 
8.21583836257749, 
8.22192191643779, 
8.22800097228969, 
8.23407554009556, 
8.24014562978107, 
8.24621125123532, 
8.2522724143111, 
8.25832912882503, 
8.26438140455775, 
8.27042925125413, 
8.27647267862342, 
8.28251169633946, 
8.28854631404084, 
8.29457654133109, 
8.30060238777885, 
8.30662386291808, 
8.31264097624816, 
8.31865373723417, 
8.32466215530696, 
8.33066623986341, 
8.33666600026653, 
8.34266144584569, 
8.34865258589672, 
8.35463942968217, 
8.36062198643139, 
8.36660026534076, 
8.37257427557379, 
8.37854402626136, 
8.38450952650183, 
8.39047078536121, 
8.39642781187333, 
8.40238061504, 
8.40832920383116, 
8.41427358718505, 
8.42021377400836, 
8.42614977317636, 
8.43208159353312, 
8.43800924389159, 
8.44393273303382, 
8.44985206971104, 
8.45576726264388, 
8.46167832052247, 
8.46758525200662, 
8.47348806572594, 
8.47938677028003, 
8.48528137423857, 
8.49117188614151, 
8.4970583144992, 
8.50294066779253, 
8.50881895447306, 
8.5146931829632, 
8.52056336165632, 
8.52642949891688, 
8.53229160308062, 
8.53814968245463, 
8.54400374531753, 
8.54985379991962, 
8.55569985448298, 
8.5615419172016, 
8.56737999624156, 
8.57321409974112, 
8.57904423581089, 
8.5848704125339, 
8.59069263796581, 
8.59651092013498, 
8.60232526704263, 
8.60813568666294, 
8.61394218694321, 
8.61974477580398, 
8.62554346113913, 
8.63133825081603, 
8.63712915267567, 
8.64291617453276, 
8.64869932417586, 
8.65447860936752, 
8.66025403784439, 
8.66602561731732, 
8.67179335547152, 
8.67755725996665, 
8.68331733843696, 
8.68907359849138, 
8.69482604771366, 
8.70057469366248, 
8.70631954387157, 
8.7120606058498, 
8.71779788708135, 
8.72353139502576, 
8.72926113711808, 
8.73498712076898, 
8.74070935336486, 
8.74642784226795, 
8.75214259481643, 
8.75785361832453, 
8.76356092008266, 
8.7692645073575, 
8.77496438739212, 
8.78066056740608, 
8.78635305459552, 
8.79204185613331, 
8.79772697916911, 
8.8034084308295, 
8.8090862182181, 
8.81476034841561, 
8.82043082847998, 
8.82609766544649, 
8.83176086632785, 
8.83742043811428, 
8.84307638777366, 
8.84872872225158, 
8.85437744847146, 
8.86002257333468, 
8.8656641037206, 
8.87130204648675, 
8.87693640846886, 
8.88256719648098, 
8.88819441731559, 
8.89381807774366, 
8.8994381845148, 
8.90505474435727, 
8.91066776397819, 
8.9162772500635, 
8.92188320927819, 
8.92748564826626, 
8.93308457365092, 
8.93867999203462, 
8.94427190999916, 
8.94986033410578, 
8.95544527089525, 
8.96102672688794, 
8.96660470858396, 
8.97217922246318, 
8.97775027498538, 
8.98331787259028, 
8.98888202169769, 
8.99444272870754, 
9, 
9.00555384193554, 
9.01110426085505, 
9.01665126307988, 
9.02219485491197, 
9.02773504263389, 
9.03327183250897, 
9.03880523078133, 
9.04433524367601, 
9.04986187739901, 
9.05538513813742, 
9.06090503205944, 
9.06642156531451, 
9.07193474403338, 
9.07744457432817, 
9.08295106229248, 
9.08845421400141, 
9.09395403551173, 
9.09945053286186, 
9.10494371207203, 
9.1104335791443, 
9.11592014006266, 
9.1214034007931, 
9.12688336728371, 
9.1323600454647, 
9.13783344124853, 
9.14330356052997, 
9.14877040918614, 
9.15423399307665, 
9.15969431804359, 
9.16515138991168, 
9.1706052144883, 
9.17605579756357, 
9.18150314491042, 
9.18694726228468, 
9.19238815542512, 
9.19782583005354, 
9.20326029187483, 
9.20869154657707, 
9.21411959983156, 
9.21954445729289, 
9.22496612459905, 
9.23038460737146, 
9.23579991121506, 
9.24121204171834, 
9.24662100445346, 
9.2520268049763, 
9.25742944882649, 
9.26282894152753, 
9.26822528858681, 
9.2736184954957, 
9.27900856772964, 
9.28439551074813, 
9.28977932999487, 
9.2951600308978, 
9.30053761886914, 
9.30591209930547, 
9.31128347758783, 
9.31665175908169, 
9.32201694913714, 
9.32737905308882, 
9.33273807625608, 
9.338094023943, 
9.34344690143846, 
9.3487967140162, 
9.35414346693485, 
9.35948716543807, 
9.36482781475453, 
9.37016542009798, 
9.37549998666738, 
9.38083151964686, 
9.38616002420585, 
9.39148550549912, 
9.39680796866681, 
9.40212741883453, 
9.40744386111339, 
9.41275730060008, 
9.41806774237688, 
9.4233751915118, 
9.42867965305853, 
9.4339811320566, 
9.43927963353137, 
9.44457516249408, 
9.44986772394196, 
9.45515732285825, 
9.46044396421225, 
9.46572765295939, 
9.47100839404126, 
9.47628619238571, 
9.48156105290685, 
9.48683298050514, 
9.49210198006743, 
9.49736805646701, 
9.50263121456368, 
9.50789145920377, 
9.51314879522022, 
9.51840322743264, 
9.5236547606473, 
9.52890339965728, 
9.53414914924242, 
9.53939201416946, 
9.54463199919201, 
9.54986910905066, 
9.555103348473, 
9.5603347221737, 
9.5655632348545, 
9.57078889120432, 
9.57601169589929, 
9.58123165360279, 
9.58644876896549, 
9.59166304662544, 
9.59687449120806, 
9.60208310732624, 
9.60728889958036, 
9.61249187255833, 
9.61769203083567, 
9.62288937897553, 
9.62808392152873, 
9.63327566303384, 
9.63846460801719, 
9.64365076099296, 
9.64883412646316, 
9.65401470891774, 
9.6591925128346, 
9.66436754267966, 
9.66953980290686, 
9.67470929795826, 
9.67987603226405, 
9.6850400102426, 
9.69020123630051, 
9.69535971483266, 
9.70051545022222, 
9.70566844684074, 
9.71081870904817, 
9.7159662411929, 
9.72111104761179, 
9.72625313263026, 
9.73139250056229, 
9.73652915571047, 
9.74166310236604, 
9.74679434480896, 
9.75192288730792, 
9.75704873412037, 
9.76217188949263, 
9.76729235765983, 
9.77241014284603, 
9.77752524926425, 
9.78263768111648, 
9.78774744259373, 
9.79285453787607, 
9.79795897113271, 
9.80306074652198, 
9.80815986819138, 
9.81325634027768, 
9.81835016690686, 
9.82344135219425, 
9.82852990024449, 
9.83361581515162, 
9.83869910099908, 
9.84377976185977, 
9.8488578017961, 
9.85393322486001, 
9.85900603509299, 
9.86407623652616, 
9.86914383318026, 
9.87420882906575, 
9.87927122818278, 
9.88433103452126, 
9.88938825206089, 
9.89444288477123, 
9.89949493661167, 
9.90454441153151, 
9.90959131347, 
9.91463564635635, 
9.9196774141098, 
9.9247166206396, 
9.92975326984513, 
9.93478736561583, 
9.93981891183134, 
9.94484791236146, 
9.9498743710662, 
9.95489829179585, 
9.95991967839099, 
9.96493853468249, 
9.96995486449161, 
9.97496867163, 
9.97997995989972, 
9.98498873309329, 
9.98999499499374, 
9.99499874937461, 
10, 
10.0049987506246, 
10.0099950049938, 
10.0149887668434, 
10.0199800399003, 
10.0249688278817, 
10.0299551344959, 
10.0349389634417, 
10.0399203184089, 
10.0448992030781, 
10.0498756211209, 
10.0548495761995, 
10.0598210719674, 
10.0647901120689, 
10.0697567001393, 
10.0747208398049, 
10.0796825346833, 
10.084641788383, 
10.0895986045036, 
10.0945529866359, 
10.0995049383621, 
10.1044544632553, 
10.1094015648801, 
10.1143462467922, 
10.1192885125388, 
10.1242283656583, 
10.1291658096805, 
10.1341008481266, 
10.1390334845093, 
10.1439637223326, 
10.1488915650922, 
10.1538170162752, 
10.1587400793602, 
10.1636607578175, 
10.1685790551089, 
10.1734949746879, 
10.1784085199996, 
10.1833196944808, 
10.18822850156, 
10.1931349446576, 
10.1980390271856, 
10.2029407525478, 
10.2078401241399, 
10.2127371453494, 
10.2176318195558, 
10.2225241501304, 
10.2274141404365, 
10.2323017938292, 
10.2371871136558, 
10.2420701032555, 
10.2469507659596, 
10.2518291050914, 
10.2567051239665, 
10.2615788258922, 
10.2664502141685, 
10.2713192920871, 
10.2761860629321, 
10.2810505299799, 
10.285912696499, 
10.2907725657503, 
10.295630140987, 
10.3004854254545, 
10.3053384223906, 
10.3101891350256, 
10.3150375665821, 
10.3198837202751, 
10.3247275993122, 
10.3295692068934, 
10.3344085462111, 
10.3392456204503, 
10.3440804327886, 
10.3489129863962, 
10.3537432844358, 
10.3585713300628, 
10.3633971264253, 
10.3682206766639, 
10.373041983912, 
10.3778610512957, 
10.3826778819339, 
10.3874924789383, 
10.3923048454133, 
10.397114984456, 
10.4019228991567, 
10.4067285925982, 
10.4115320678563, 
10.4163333279998, 
10.4211323760904, 
10.4259292151827, 
10.4307238483242, 
10.4355162785557, 
10.4403065089106, 
10.4450945424156, 
10.4498803820905, 
10.4546640309481, 
10.4594454919943, 
10.4642247682282, 
10.4690018626419, 
10.4737767782209, 
10.4785495179438, 
10.4833200847823, 
10.4880884817015, 
10.4928547116597, 
10.4976187776086, 
10.5023806824929, 
10.507140429251, 
10.5118980208143, 
10.5166534601079, 
10.5214067500501, 
10.5261578935526, 
10.5309068935206, 
10.5356537528527, 
10.5403984744411, 
10.5451410611713, 
10.5498815159223, 
10.554619841567, 
10.5593560409714, 
10.5640901169954, 
10.5688220724923, 
10.573551910309, 
10.5782796332863, 
10.5830052442584, 
10.5877287460531, 
10.5924501414923, 
10.5971694333912, 
10.6018866245589, 
10.6066017177982, 
10.6113147159058, 
10.6160256216722, 
10.6207344378814, 
10.6254411673116, 
10.6301458127347, 
10.6348483769163, 
10.6395488626163, 
10.6442472725881, 
10.6489436095793, 
10.6536378763313, 
10.6583300755794, 
10.6630202100531, 
10.6677082824757, 
10.6723942955646, 
10.6770782520313, 
10.6817601545813, 
10.686440005914, 
10.6911178087233, 
10.6957935656968, 
10.7004672795163, 
10.7051389528581, 
10.7098085883922, 
10.7144761887831, 
10.7191417566893, 
10.7238052947636, 
10.7284668056531, 
10.733126291999, 
10.7377837564369, 
10.7424392015966, 
10.7470926301023, 
10.7517440445725, 
10.7563934476199, 
10.7610408418517, 
10.7656862298694, 
10.770329614269, 
10.7749709976408, 
10.7796103825695, 
10.7842477716343, 
10.7888831674089, 
10.7935165724615, 
10.7981479893545, 
10.8027774206451, 
10.807404868885, 
10.8120303366204, 
10.816653826392, 
10.821275340735, 
10.8258948821795, 
10.8305124532498, 
10.8351280564652, 
10.8397416943394, 
10.8443533693808, 
10.8489630840924, 
10.8535708409721, 
10.8581766425123, 
10.8627804912002, 
10.8673823895177, 
10.8719823399415, 
10.876580344943, 
10.8811764069884, 
10.8857705285386, 
10.8903627120496, 
10.8949529599719, 
10.899541274751, 
10.9041276588272, 
10.9087121146357, 
10.9132946446066, 
10.9178752511649, 
10.9224539367305, 
10.9270307037182, 
10.9316055545377, 
10.9361784915939, 
10.9407495172863, 
10.9453186340097, 
10.9498858441538, 
10.9544511501033};




static I2C_HandleTypeDef* _i2c= &sensors_i2c;
static bool initialized = false;

static const uint8_t _sdp_reset_req[1]  = { 0xFE };
static const uint8_t _sdp_readAUR_req[1]  = { 0xE5 };
static uint8_t _sdp_writeAUR_req[3]  = { 0xE4, 0x00, 0x00};

static const uint8_t _sdp_measurement_req[1] 	= { 0xF1 };
static uint8_t       _sdp_measurement_buffer[3] = { 0 };
static uint8_t       _sdp_AUR_buffer[3] 		= { 0 };

static uint8_t       _npa_measurement_buffer[2]	= { 0 };

static struct bmp280_dev bmp;
struct bmp280_uncomp_data ucomp_data;
static uint8_t bmp280_DMA_buffer[6];

static volatile float _current_flow_slm;
static volatile float _current_Patmo_mbar;
static volatile float _current_Paw_cmH2O;
static volatile float _current_temp_degreeC;
static volatile float _current_vol_mL;
static volatile	uint16_t last_sdp_t_us;
static volatile	uint16_t last_npa_t_us;
volatile sensors_state_t _sensor_state;
			
				

static volatile float buffer_flow_slm[4]	={0};
static volatile float buffer_Paw_cmH2O[4]	={0};
static volatile float buffer_RPaw_cmH2O[4]	={0};
static volatile float paw_max = 0;
static volatile float vol_brut = 0;
static volatile float vol_max = 0;
static volatile	uint16_t last_flow_t_us;

#define FLOW_SAMPLE_DELTA 20000

static void process_i2c_callback(I2C_HandleTypeDef *hi2c);

//--- BMP280
static int8_t bmp280_write_direct(uint8_t i2c_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t length);
static int8_t bmp280_read_direct(uint8_t i2c_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t length);

static void bmp280_delay_ms(uint32_t period_ms);
//---

static bool initBMP280();
static bool initSDP610();



static inline uint16_t get_time_us() { return timer_us.Instance->CNT; }

bool init_sensors() {
	if (initialized)
		return true;


    if (!initSDP610() || !initBMP280())
        return false;

    // Sensors settle time
    HAL_Delay(100);

    initialized = true;

    _i2c->MasterTxCpltCallback = process_i2c_callback;
    _i2c->MasterRxCpltCallback = process_i2c_callback;
    _i2c->ErrorCallback = process_i2c_callback;

    return true;
}	

static bool initSDP610() 
{
	//
	// Scan I2C bus
	// TODO: Check if all sensors are responding.
	for (int t = 1; t < 127; ++t) {
		if(HAL_I2C_IsDeviceReady(_i2c, (uint16_t)(t<<1), 2, 2) == HAL_OK) {
			//dbg_printf("Found device at address: %02X\n", t);
		}

	}
	// First try to complete pending sdp rad request if any !!!
	if (HAL_I2C_Master_Receive(_i2c, ADDR_SPD610, (uint8_t*) _sdp_measurement_buffer, sizeof(_sdp_measurement_buffer), 1000) != HAL_I2C_ERROR_NONE) {
		//dbg_printf("Tried to finished pending sdp read request... but nothing came...\n");
	}

	// Reset SDP
	if (HAL_I2C_Master_Transmit(_i2c, ADDR_SPD610, (uint8_t*) _sdp_reset_req, sizeof(_sdp_reset_req), 1000) != HAL_I2C_ERROR_NONE) {
		return false;
	}

	HAL_Delay(100);
	// Now read sdp advanced user register
	if (HAL_I2C_Master_Transmit(_i2c, ADDR_SPD610, (uint8_t*) _sdp_readAUR_req, sizeof(_sdp_readAUR_req), 1000) != HAL_I2C_ERROR_NONE) {
		return false;
	}
	HAL_Delay(100);
	if (HAL_I2C_Master_Receive(_i2c, ADDR_SPD610, (uint8_t*) _sdp_AUR_buffer, sizeof(_sdp_AUR_buffer), 1000) != HAL_I2C_ERROR_NONE) {
		return false;
	}
	// print AUR (Advances User Register)
	uint16_t sdp_aur = (uint16_t)((_sdp_AUR_buffer[0] << 8) | _sdp_AUR_buffer[1]);
	//	printf("sdp AUR = %d\n", (uint16_t)(sdp_aur));
	uint16_t sdp_aur_no_i2c_hold = sdp_aur & 0xFFFD;
	_sdp_writeAUR_req[1] = (uint16_t)(sdp_aur_no_i2c_hold >> 8);
	_sdp_writeAUR_req[2] = (uint16_t)(sdp_aur_no_i2c_hold & 0xFF);
	// Now disable i2c hold master mode
	if (HAL_I2C_Master_Transmit(_i2c, ADDR_SPD610, (uint8_t*) _sdp_writeAUR_req, sizeof(_sdp_writeAUR_req), 1000) != HAL_I2C_ERROR_NONE) {
		return false;
	}

	return true;
}


static bool initBMP280() {

    struct bmp280_config conf;

    /* Map the delay function pointer with the function responsible for implementing the delay */
    bmp.delay_ms = bmp280_delay_ms;

    /* Assign device I2C address based on the status of SDO pin (GND for PRIMARY(0x76) & VDD for SECONDARY(0x77)) */
    bmp.dev_id = BMP280_I2C_ADDR_PRIM;

    /* Select the interface mode as I2C */
    bmp.intf = BMP280_I2C_INTF;

    /* Map the I2C read & write function pointer with the functions responsible for I2C bus transfer */
    bmp.read = bmp280_read_direct;
    bmp.write = bmp280_write_direct;

    if (bmp280_init(&bmp) != BMP280_OK)
        return false;
    /* Always read the current settings before writing, especially when
     * all the configuration is not modified
     */

    if (bmp280_get_config(&conf, &bmp) != BMP280_OK)
        return false;

    /* configuring the temperature oversampling, filter coefficient and output data rate */
    /* Overwrite the desired settings */
    conf.filter = BMP280_FILTER_COEFF_2;


    /* Temperature oversampling set at 4x */
    conf.os_temp = BMP280_OS_4X;
   
    /* Pressure oversampling set at 4x */
    conf.os_pres = BMP280_OS_4X;

    /* Setting the output data rate as 1HZ(1000ms) */
    conf.odr = BMP280_ODR_1000_MS;
    if (bmp280_set_config(&conf, &bmp) != BMP280_OK)
        return false;

    /* Always set the power mode after setting the configuration */
    if (bmp280_set_power_mode(BMP280_NORMAL_MODE, &bmp) != BMP280_OK)
        return false;


    return true;
}

//! \returns false in case of hardware failure
bool is_sensors_ok() {
  return initialized;
}

//! \returns false in case of hardware failure
bool is_Pdiff_ok() {
  return initialized;
}

bool is_Paw_ok() {
  return initialized;
}

bool is_Patmo_ok() {
  return initialized;
}

//! \returns the airflow corresponding to a pressure difference in Liters / minute
float read_Pdiff_Lpm() {
	// TODO: correct with ambiant pressure and T°
  return _current_flow_slm;
}

//! \returns the sensed pressure in cmH2O (1,019mbar in standard conditions)
float read_Paw_cmH2O() {
  return _current_Paw_cmH2O;
}

//! \returns the atmospheric pressure in mbar
float read_Patmo_mbar() {
  return _current_Patmo_mbar;
}

//! \returns the atmospheric pressure in mbar
float read_temp_degreeC() {
  return _current_temp_degreeC;
}

 //! \returns the current integrated volume
float read_Vol_mL() {
	return _current_vol_mL;
}

 //! reset current integrated volume to 0
void reset_Vol_mL() {
	_current_vol_mL = 0;
	paw_max 	= 0;
	vol_brut 	= 0;
	vol_max 	= 0;
}
static void readSDP() {
	_sensor_state = READ_SDP_MEASUREMENT;
	HAL_I2C_Master_Receive_DMA(_i2c, ADDR_SPD610, (uint8_t*) _sdp_measurement_buffer, sizeof(_sdp_measurement_buffer));
}

static void reqSDP() {
	_sensor_state = REQ_SDP_MEASUREMENT;
	HAL_I2C_Master_Transmit_IT(_i2c, ADDR_SPD610, (uint8_t*) _sdp_measurement_req, sizeof(_sdp_measurement_req));
}

static void readNPA() {
	_sensor_state = READ_NPA_MEASUREMENT;
	HAL_I2C_Master_Receive_DMA(_i2c, ADDR_NPA700B, (uint8_t*) _npa_measurement_buffer, sizeof(_npa_measurement_buffer));
}

static void readBMP280_stage_1() {
    _sensor_state = READ_BMP280_STAGE_1;
    bmp280_DMA_buffer[0] = BMP280_PRES_MSB_ADDR;
    /*
     * Envoi de l'adresse du premier registre à lire. Dans un deuxième temps (après interruption = readBMP280_stage_2), on lira la donnée
     * Cet envoi n'est pas fait en DMA car le capteur termine la séquence par un ACK qui ne lève pas l'interruptions et
     * qui ne permet pas de rentrer dans la machine d'état. On utilise donc la fonction d'envoi avec interruptions moins
     * gourmande que la version synchone. (mais la version synchrone fonctionne également si besoin.)
     */
    HAL_I2C_Master_Transmit_IT(_i2c, BMP280_I2C_ADDR_PRIM << 1, bmp280_DMA_buffer, 1);
}

static void readBMP280_stage_2() {
    uint8_t bytesToRead = 6;
    assert(bytesToRead <= sizeof(bmp280_DMA_buffer));
    _sensor_state = READ_BMP280_STAGE_2;
    HAL_I2C_Master_Receive_DMA(_i2c, BMP280_I2C_ADDR_PRIM << 1, bmp280_DMA_buffer, bytesToRead);
}


//--- BMP280 library callbacks

static int8_t bmp280_write_direct(uint8_t i2c_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t length) {
    assert(length <= sizeof(bmp280_DMA_buffer));
    bmp280_DMA_buffer[0] = reg_addr;
    memcpy(bmp280_DMA_buffer + 1, reg_data, length);
    return HAL_I2C_Master_Transmit(_i2c, i2c_addr << 1, bmp280_DMA_buffer, length + 1, 1000);
}

static int8_t bmp280_read_direct(uint8_t i2c_addr, uint8_t reg_addr, uint8_t *reg_data, uint16_t length) {
    //--- envoi l'adresse du registre à lire
    HAL_StatusTypeDef r = HAL_I2C_Master_Transmit(_i2c, i2c_addr << 1, &reg_addr, 1, 1000);
    if (r != HAL_OK)
        return r;
    //--- réception de la donnée
    return HAL_I2C_Master_Receive(_i2c, i2c_addr << 1, reg_data, length, 1000);
}

/**
 * bmp280_delay_ms n'est appelée par la lib bmp280 que lors de l'initialisation, cela ne pose donc
 * pas de pb de temps perdu dans le fonctionnement régulier du système.
 */
static void bmp280_delay_ms(uint32_t period_ms) {
    HAL_Delay(period_ms);
}

//---



bool sensors_start() {
    // Start the sensor state machine.
    // This state machine is managed in the I2C interupt routine.
	HAL_TIM_Base_Start(&timer_us);
	reqSDP();
	return true;
}

float compute_corrected_pressure(uint16_t read)
{
    return 1.01972f/*mbar/cmH2O*/
                        * (160.f*(read - 1638.f)/13107.f); // V1 Calibration
}

//! \warning TODO compute corrected QPatientSLM (Standard Liters per Minute) based on Patmo
float compute_corrected_flow(int16_t read)
{
   #if		1
   return -(float) read / 105.f;
   #else
   
   uint16_t current_time = (uint16_t)get_time_us();
    uint16_t dt_time = current_time - last_flow_t_us;
    last_flow_t_us = current_time;
    buffer_flow_slm[3]=buffer_flow_slm[2];
    buffer_flow_slm[2]=buffer_flow_slm[1];
    buffer_flow_slm[1]=buffer_flow_slm[0];
    buffer_Paw_cmH2O[3]=buffer_Paw_cmH2O[2];
    buffer_Paw_cmH2O[2]=buffer_Paw_cmH2O[1];
    buffer_Paw_cmH2O[1]=buffer_Paw_cmH2O[0];
    buffer_RPaw_cmH2O[3]=buffer_RPaw_cmH2O[2];
    buffer_RPaw_cmH2O[2]=buffer_RPaw_cmH2O[1];
    buffer_RPaw_cmH2O[1]=buffer_RPaw_cmH2O[0];

    buffer_Paw_cmH2O[0]=_current_Paw_cmH2O; 
	
	float	input_racine = buffer_Paw_cmH2O[0];
				if( input_racine < 0.000001f ) input_racine = 0.000001f;
	#if		1
				if( input_racine > 120 ) input_racine = 120;
	
		buffer_RPaw_cmH2O[0] = TAB_sqrtf[ (int)round( input_racine*10 ) ];
	#else
		buffer_RPaw_cmH2O[0] = sqrtf( input_racine );
	#endif
	
    buffer_flow_slm[0]=-(float) read / 105.f;

    float sum = buffer_flow_slm[0] + buffer_flow_slm[1] + buffer_flow_slm[2] + buffer_flow_slm[3];
    float acc = ( buffer_flow_slm[0] - buffer_flow_slm[3] ) /4;
	
    paw_max = MAX(paw_max, buffer_Paw_cmH2O[0]);
	
    float pv = paw_max / MAX(vol_max,10);
	
    vol_brut+=buffer_flow_slm[0]*((float)dt_time/1000);
	
    vol_max = MAX(vol_max, vol_brut);
    float pneumo=0;
    if ((sum<-0.10) && (pv<=1))
	pneumo=-0.2 + (0.86)*buffer_flow_slm[2] + (-3.13)*buffer_RPaw_cmH2O[0] + (0.58)*buffer_Paw_cmH2O[0];
    else if ((0.10<sum) && (pv<=1))
	pneumo=3.2 + (0.89)*buffer_flow_slm[2] + (-0.44)*buffer_RPaw_cmH2O[0] + (-0.01)*buffer_Paw_cmH2O[0];
    else if ((0.10<sum) && (1<pv))
	pneumo=2.1 + (0.91)*buffer_flow_slm[2] + (0.26)*buffer_RPaw_cmH2O[0] + (-0.07)*buffer_Paw_cmH2O[0];
    else if ((sum<-0.10) && (pv<=1) && (acc<-13))
	pneumo=158.5 + (0.93)*buffer_flow_slm[2] + (-59.25)*buffer_RPaw_cmH2O[0] + (5.18)*buffer_Paw_cmH2O[0];
    else if ((sum<-0.10) && (pv<=1) && (5<acc))
	pneumo=13.5 + (-4.23)*buffer_flow_slm[2] + (33.99)*buffer_RPaw_cmH2O[0] + (-40.40)*buffer_Paw_cmH2O[0];
    else if ((0.10<sum) && (pv<=1) && (5<acc))
	pneumo=172.8 + (0.76)*buffer_flow_slm[2] + (-154.49)*buffer_RPaw_cmH2O[0] + (35.21)*buffer_Paw_cmH2O[0];
    else if ((0.10<sum) && (pv<=1) && (acc<-13))
	pneumo=28.1 + (0.46)*buffer_flow_slm[2] + (3.43)*buffer_RPaw_cmH2O[0] + (-0.62)*buffer_Paw_cmH2O[0];
    else if ((sum<-0.10) && (1<pv))
	pneumo=-0.2 + (0.71)*buffer_flow_slm[2] + (-5.61)*buffer_RPaw_cmH2O[0] + (0.71)*buffer_Paw_cmH2O[0];
    else if ((sum<-0.10) && (1<pv) && (acc<-13))
	pneumo=198.9 + (-0.49)*buffer_flow_slm[2] + (-187.62)*buffer_RPaw_cmH2O[0] + (22.02)*buffer_Paw_cmH2O[0];
    else if ((sum<-0.10) && (1<pv) && (5<acc))
	pneumo=14.0 + (0.00)*buffer_flow_slm[2] + (-20.87)*buffer_RPaw_cmH2O[0] + (-0.88)*buffer_Paw_cmH2O[0];
    else pneumo=buffer_flow_slm[0];


    return pneumo; // V1 Calibration
	#endif
}

void		hardfault_CRASH_ME(
		// string 		message_err /// WIP code fatal error : todo
){
	// #error	"not_in_production !!!!"
	
	motor_release(MOTOR_RELEASE_STEP_US);
	
	// ALARM_fatale( message_err ); /// WIP
	printf( "hardfault_CRASH_ME\n\r" );
	wait_ms( 3000 );
	
	/// provoque un crash du MCU
	uint8_t* 	BytePtr = (uint8_t)0x20002000;
					*BytePtr = 0x5a;        //generate hardfault IRQ		
					
	return; /// jamais
}

static void process_i2c_callback(I2C_HandleTypeDef *hi2c) {
	switch (_sensor_state) {
		case STOPPING:
			_sensor_state = STOPPED;
			return;
		case STOPPED:
			return;
		case READ_NPA_MEASUREMENT: {
			if (HAL_I2C_GetError(hi2c) == HAL_I2C_ERROR_AF) {
				// Retry
				readNPA();
				break;
			}
			if (HAL_I2C_GetError(hi2c) != HAL_I2C_ERROR_NONE) {
				// skip
				readSDP();
				break;
			}
			if (HAL_I2C_GetError(hi2c) == HAL_I2C_ERROR_NONE) {
				if ((_npa_measurement_buffer[0] >> 6) == 0) {
					uint16_t npa_t_us = (uint16_t)get_time_us();
					uint16_t npa_dt_us = (uint16_t)npa_t_us - last_npa_t_us;
					uint16_t praw = (((uint16_t) _npa_measurement_buffer[0]) << 8 | _npa_measurement_buffer[1]) & 0x3FFF;
					_current_Paw_cmH2O = compute_corrected_pressure(praw);
					last_npa_t_us = npa_t_us;
				} else if ((_npa_measurement_buffer[0] >> 6) == 3) {
					// TODO: Manage error status !!
				}
			}
			readSDP();

			break;
		}
		case REQ_SDP_MEASUREMENT: {
			if (HAL_I2C_GetError(hi2c) == HAL_I2C_ERROR_AF) {
					// retry
					reqSDP();
					break;
			}
			if (HAL_I2C_GetError(hi2c) != HAL_I2C_ERROR_NONE) {
				// skip
				readSDP();
				break;
			}
			readSDP();
			break;
		}
		case READ_SDP_MEASUREMENT: {
			if (HAL_I2C_GetError(hi2c) == HAL_I2C_ERROR_AF) {
				readNPA();
				break;
			}
			if (HAL_I2C_GetError(hi2c) != HAL_I2C_ERROR_NONE) {
				// Skip
				readBMP280_stage_1();
				break;
			}
			if (_sdp_measurement_buffer[0] != 0xFF || _sdp_measurement_buffer[1] != 0xFF || _sdp_measurement_buffer[2] != 0xFF) {
				uint16_t sdp_t_us = (uint16_t)get_time_us();
				uint16_t sdp_dt_us = (uint16_t)sdp_t_us - last_sdp_t_us;
				int16_t dp_raw   = (int16_t)((((uint16_t)_sdp_measurement_buffer[0]) << 8) | (uint8_t)_sdp_measurement_buffer[1]);
				
				
				
				
				
				
				
				
				
				
				
				/// bloc code adrien WIP
				/// bloc code adrien WIP
				/// bloc code adrien WIP
				static uint32_t 	Ancien_maintenant = 0;
				uint32_t				maintenant = get_time_ms();
				if(
							GLOB_is_running_sampling_temps_moteur 		== 	true /// on souhaite l'acquisition en IT
					&&	maintenant 													>= 	GLOB_TIMER_ms_debut_sampling_temps_moteur
					&&	maintenant 													<= 	GLOB_TIMER_ms_fin_sampling_temps_moteur
					&&	maintenant 													>= 	Ancien_maintenant + 6 /// frequence echantillongae periodique todo !!
				){
					
					if( 
						GLOB_index_TAB_dp_raw_temps_moteur < (int32_t)( NBR_VALEURS_TAB_debits_temps_moteur * DIVISEUR_NBR_VALEURS_SAMPLED )
					){
						/// on accumule les samples
						GLOB_accumule_TAB_dp_raw_temps_moteur 				+= dp_raw;
						GLOB_accumule_TAB_TIMECODE_temps_moteur 		+= maintenant;
						GLOB_denom_TAB_dp_raw_temps_moteur++;
						
						/// on ecrase quoiqu'il arrive : todo moyenne glissante
						TAB_dp_raw_temps_moteur[ ( GLOB_index_TAB_dp_raw_temps_moteur ) / DIVISEUR_NBR_VALEURS_SAMPLED ].dp_raw 							= dp_raw; /// GLOB_accumule_TAB_dp_raw_temps_moteur 			/ GLOB_denom_TAB_dp_raw_temps_moteur;
						// TAB_dp_raw_temps_moteur[ ( GLOB_index_TAB_dp_raw_temps_moteur ) / DIVISEUR_NBR_VALEURS_SAMPLED ].Paw = round( _current_Paw_cmH2O ); /// on ecrase a chaque fois car on cherche le max... pas grave
						TAB_dp_raw_temps_moteur[ ( GLOB_index_TAB_dp_raw_temps_moteur ) / DIVISEUR_NBR_VALEURS_SAMPLED ].timecode_sample_MS 	= GLOB_accumule_TAB_TIMECODE_temps_moteur 	/ GLOB_denom_TAB_dp_raw_temps_moteur;
						GLOB_index_TAB_dp_raw_temps_moteur++;
						
						if( ( GLOB_index_TAB_dp_raw_temps_moteur % DIVISEUR_NBR_VALEURS_SAMPLED ) == 0 ){ 
							/// MAJ pour future valeur
							GLOB_denom_TAB_dp_raw_temps_moteur = 0;
							GLOB_accumule_TAB_dp_raw_temps_moteur = 0;
							GLOB_accumule_TAB_TIMECODE_temps_moteur = 0;
						} 
						// else {
							/// todo moyenne glissante
						// }
						
						
						
						
					} else {
						/// crash !!! WIP : attention virer en prod !!!!
						GLOB_index_TAB_dp_raw_temps_moteur++; /// sera detected ds breathing pr generer un crash proprement ;)
						// brth_printf( "CRASH TAB_dp_raw_temps_moteur %i", GLOB_index_TAB_dp_raw_temps_moteur );
						// hardfault_CRASH_ME();
					}
				}
				/// bloc code adrien WIP
				/// bloc code adrien WIP
				
				
				
				/// bloc code Germain
				/// bloc code Germain
				if(sdp_dt_us> FLOW_SAMPLE_DELTA)
				{
				    _current_flow_slm = compute_corrected_flow(dp_raw);
							
							/// MAJ Volume
      			            _current_vol_mL += (_current_flow_slm/60.) * ((float)sdp_dt_us/1000);
							
							/// remember errur liee a phase accel
							if( 
										maintenant > GLOB_TIMER_fin_accel_moteur_ms
								&&	GLOB_Volume_erreur_phase_accel == -12345.0f /// MAJ needed
								&&	GLOB_timecode_ms_full_speed != 0
							){ /// GLOB_timecode_ms_full_speed ){
								float	Volume_attendu_mL = 			( 
																										( 30.0f + GLOB_debit_from_error_slm ) /// get_setting_Vmax_Lpm()  // debit_consigne_slm
																								/ 		60.0f /// min to sec : MODIF_POST_COMMIT
																							)
																					* 	GLOB_timecode_ms_full_speed
																					// / 1000
																				;
																				
								GLOB_Volume_erreur_phase_accel = Volume_attendu_mL - _current_vol_mL;
								
								#define		ATTENUATION_OSCILLATION_COMP_VOLUME_ERR			0.85f
								GLOB_debit_from_error_slm = ATTENUATION_OSCILLATION_COMP_VOLUME_ERR * 60.0f * GLOB_Volume_erreur_phase_accel / ( 1000 - GLOB_timecode_ms_full_speed );
								
								printf( "--%i mL deb comp %i full speed %i ms\n\r", (int)( Volume_attendu_mL ), (int)( GLOB_debit_from_error_slm * 1000 ), (int)( GLOB_timecode_ms_full_speed ) );
							}
							
				    last_sdp_t_us = sdp_t_us;
				}
				/// bloc code Germain
				/// bloc code Germain
				/// bloc code Germain
				
				
				
				
				
				
				
				
				
				
				
				
				
        		        readSDP();
			} else {
				readBMP280_stage_1();
            }
            break;
        }
        case READ_BMP280_STAGE_1: {
            readBMP280_stage_2();
            break;
        }
        case READ_BMP280_STAGE_2: {
            uint8_t *temp = bmp280_DMA_buffer;
            uint32_t uncomp_press = (int32_t)((((uint32_t)(temp[0])) << 12) | (((uint32_t)(temp[1])) << 4) | ((uint32_t) temp[2] >> 4));
            uint32_t uncomp_temp = (int32_t)((((int32_t)(temp[3])) << 12) | (((int32_t)(temp[4])) << 4) | (((int32_t)(temp[5])) >> 4));

            if ((uncomp_press > BMP280_ST_ADC_P_MIN) && (uncomp_press < BMP280_ST_ADC_P_MAX)) {
                uint32_t pressure_Pa;
                bmp280_get_comp_pres_32bit(&pressure_Pa, uncomp_press, &bmp); // inutile de gérer l'erreur, la fonction appelée vérifie juste que bmp n'est pas null.
				_current_Patmo_mbar = (float)pressure_Pa / 100.0;
            } else {
                // todo gérer l'erreur
             }

            if ((uncomp_temp > BMP280_ST_ADC_T_MIN) && (uncomp_temp < BMP280_ST_ADC_T_MAX)) {
                int32_t temperature_degreeCx100;
                bmp280_get_comp_temp_32bit(&temperature_degreeCx100, uncomp_temp, &bmp); // inutile de gérer l'erreur, la fonction appelée vérifie juste que bmp n'est pas null.
				_current_temp_degreeC = (float)temperature_degreeCx100 / 100.0;
            } else {
                // todo gérer l'erreur
            }
            readNPA();
			break;
		}
	}
}














